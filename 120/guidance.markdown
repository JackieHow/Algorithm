让我们用一个简单的符号示例来逐步演示在题目 120 "三角形最小路径和" 中如何使用动态规划自底向上计算最小路径和。

### 初始三角形
假设我们有如下三角形，其中数字代表每个点的权重：

```
     2
    3 4
   6 5 7
  4 1 8 3
```

### 初始化 `dp` 数组
我们首先将 `dp` 数组初始化为三角形的最后一行：

```
dp = [4, 1, 8, 3]
```

### 动态规划过程
接下来，我们从三角形的倒数第二行开始，向上计算每一行的最小路径和。我们更新 `dp` 数组，使其始终保持从当前行到底部的最小路径和。

#### 计算第三行：
- 对于元素 `6`（索引 `0`）:
  ```
  dp[0] = 6 + min(dp[0], dp[1]) = 6 + min(4, 1) = 6 + 1 = 7
  ```
- 对于元素 `5`（索引 `1`）:
  ```
  dp[1] = 5 + min(dp[1], dp[2]) = 5 + min(1, 8) = 5 + 1 = 6
  ```
- 对于元素 `7`（索引 `2`）:
  ```
  dp[2] = 7 + min(dp[2], dp[3]) = 7 + min(8, 3) = 7 + 3 = 10
  ```

更新后的 `dp` 数组：
```
dp = [7, 6, 10, 3]
```

#### 计算第二行：
- 对于元素 `3`（索引 `0`）:
  ```
  dp[0] = 3 + min(dp[0], dp[1]) = 3 + min(7, 6) = 3 + 6 = 9
  ```
- 对于元素 `4`（索引 `1`）:
  ```
  dp[1] = 4 + min(dp[1], dp[2]) = 4 + min(6, 10) = 4 + 6 = 10
  ```

更新后的 `dp` 数组：
```
dp = [9, 10, 10, 3]
```

#### 计算第一行（顶点）：
- 对于顶点 `2`（索引 `0`）:
  ```
  dp[0] = 2 + min(dp[0], dp[1]) = 2 + min(9, 10) = 2 + 9 = 11
  ```

更新后的 `dp` 数组：
```
dp = [11, 10, 10, 3]
```

### 结果
最终，`dp[0]` 存储了从三角形顶部到底部的最小路径和，为 `11`。

### 符号解释
在这个过程中，`min` 函数用于选择两个可能路径中的较小值，保证我们总是取得最小的路径和。`dp` 数组被迭代地更新，以确保每一步都基于当前最优解。

希望这个符号表示的步骤清晰地展示了如何通过动态规划从底部开始逐行向上计算出三角形的最小路径和。如果您有任何疑问或需要更多的解释，请随时告诉我！